<!DOCTYPE html>
<html>
<head>
	<title>Music Vis With Shaders</title>
</head>

<style>
    body{
        margin: 0;
        overflow: hidden;
        background-color: black;
    }

    #loading, #start{
        height: 100vh;
        width: 100vw;
        position: fixed;
    }

    #loading{
        background-color: black;
        z-index: 2000;
    }

    #start{
        z-index: 1000;
        opacity: 1;
        transition: all .5s ;
    }

    #start .startButton{
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-family: sans-serif;
        font-size: 35px;
        font-weight: lighter;
        text-align: center;
        text-decoration: none;
    }

    #start .startButton a:hover{
        cursor: pointer;
    }


    #loading h1 {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-family: sans-serif;
        font-size: 1em;
        font-weight: lighter;
        text-align: center;
    }

    #description{
        position: absolute;
        bottom: 0;
        left: 0;
        margin: 25px;
        color: white;
        font-family: Helvetica, sans-serif;
    }

    #play{
        font-family: Helvetica;
        font-size: 1em;
        position: absolute;
        margin: 25px;
        color: white;
        bottom: 0;
        right: 0;
        z-index: 3;
    }

    #play:hover{
        cursor: pointer;
    }

    #song{
        font-family: Helvetica;
        font-size: 1em;
        position: absolute;
        margin: 25px;
        color: white;
        bottom: 0;
        left: 0;
        z-index: 3;
    }

    #song:hover{
        cursor: pointer;
    }

    a{
        text-decoration: underline;
        color: white;
    }

    #container{
        position:absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
</style>
<body>
    <div id="loading"><h1>LOADING</h1></div>
    <div id="start">
        <div class="startButton">
            <a>START</a>
        </div>
    </div>
	<div id="container"></div>
    <div id="play" onclick="toggleplay()">play</div>
    <div id="song" onclick="toggleSong()">another song</div>
</body>
<script type="vsh" id="vertexShader">
    
    void main(){

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);

    }

</script>
<script type="fsh" id="fragmentShaderBryan">

    uniform float time;
    uniform float volume;
    uniform vec2 resolution;
    uniform mat4 freqData[16];

    vec2 random2( vec2 p ) {
        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
    }

    void main(){

        vec2 st = gl_FragCoord.xy/resolution.xy;
        st = st-1.;

        st *= 2.;
        // st *= (2. - 1.5*volume);

        vec2 i_st = floor(st);
        vec2 f_st = fract(st);

        vec3 color = vec3(1.);

        float m_dist = .1 + .9 * volume;  // minimun distance

        for (int y= -1; y <= 1; y++) {
            for (int x= -1; x <= 1; x++) {
                // Neighbor place in the grid
                vec2 neighbor = vec2(float(x),float(y));

                // Random position from current + neighbor place in the grid
                vec2 point = random2(i_st + neighbor);

                float vol = volume * 2. - 1.;
                // Animate the point
                point = vec2(.5 * vol * .25 * random2(st).x, .5 * vol * .25 * random2(st).y) + vec2(.5*sin(time + 6.2831*point));

                // Vector between the pixel and the point
                vec2 diff = neighbor + point + f_st;

                // Distance to the point
                float dist = volume * length(diff);

                // Keep the closer distance
                m_dist = min(m_dist, dist);
            }
        }
        
        // color = vec3(1.) - distance*vec3(3.,2.,1.);
        
        //gl_FragColor = vec4(f * color, 1.);
        // gl_FragColor = vec4(color * inFunction, 1.);

        color = volume * vec3(f_st.x, i_st.y, freqData[1] / 255.);

        // Draw the min distance (distance field)
        color -= m_dist;

        // Draw cell center
        color += 1.-step(.02, m_dist);

        // Show isolines
        // color -= step(.7,abs(sin(27.0*m_dist)))*.5;

        gl_FragColor = vec4(color, 1.0);
    }

</script>
<script type="fsh" id="fragmentShaderKristie">
    
    uniform float time;
    uniform float freqData[16];
    uniform float volume;
    uniform vec2 resolution;

        // 2D Random
    float random (in vec2 st) {
        return fract(sin(dot(st.xy,
                             vec2(12.9898,78.233)))
                     * 43758.5453123);
    }

    // 2D Noise based on Morgan McGuire @morgan3d
    // https://www.shadertoy.com/view/4dS3Wd
    float noise (in vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);

        // Four corners in 2D of a tile
        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));

        // Smooth Interpolation

        // Cubic Hermine Curve.  Same as SmoothStep()
        vec2 u = f*f*(3.0-2.0*f);
        // u = smoothstep(0.,1.,f);

        // Mix 4 coorners porcentages
        return mix(a, b, u.x) +
                (c - a)* u.y * (1.0 - u.x) +
                (d - b) * u.x * u.y;
    }

    void main(){
        vec2 st = gl_FragCoord.xy/resolution.xy;
        //st *= 2.;
        st = st-1.;
        float n = noise(st);

        vec2 center = vec2(0., 0.);  
        float distance = n+distance(st, center);
        float a = atan(st.x, st.y + n) + 8.*sin(time);
        float f = cos(a*12.)*sin(a*8.)*volume+.25;
        float inFunction = smoothstep(distance, distance + .2, f);

        vec3 color = vec3(1.) - distance*vec3(3.,2.,1.);
        
        //gl_FragColor = vec4(f * color, 1.);
        gl_FragColor = vec4(color * inFunction, 1.);

    }

</script>
<script type="fsh" id="fragmentShaderYoshino">
    #ifdef GL_ES
    precision highp float;
    #endif
    #define PI 3.14159265359
    #define TWO_PI 6.28318530718
    
    //uniform float time;
    //uniform float freqData[16];
    //uniform float volume;
    #ifdef GL_ES
    precision mediump float;
    #endif
    #define PI 3.14159265359
    #define TWOPI 6.28318530718
    uniform vec2 resolution;
    //uniform vec2 u_mouse;
    uniform float time;
    uniform float freqData[16];
    uniform float volume;
        // 2D Random
float random (in vec2 st) {
    return fract(sin(dot(st.xy,
                         vec2(12.9898,78.233)))
                 * 43758.5453123);
}
// 2D Noise based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);
    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));
    // Smooth Interpolation
    // Cubic Hermine Curve.  Same as SmoothStep()
    vec2 u = f*f*(3.0-2.0*f);
    // u = smoothstep(0.,1.,f);
    // Mix 4 coorners porcentages
    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}
    void main(){
        //vec3 color = vec3(volume, 0.38, 0.76);
        //float opacity = 1.;
        //gl_FragColor = vec4(color, opacity);
        vec2 st = gl_FragCoord.xy/resolution.xy;
        st.x *= resolution.x/resolution.y;
        vec3 color = vec3(0.0, 0.0, 0.0);
        float d = 0.0;

        // for tiling
        st *= 2.;
        st = fract(st);

        st = st/2. - .25;
        int N = 5;
        float n = noise(vec2(volume,volume));

        float a = atan(st.x,st.y) + PI;
        float r = TWOPI/float(N);
    
        //d = cos(floor(0.5+a/r)*r-a)*length(st)*8.0*volume;
        //d = cos(floor(noise(st)+a/r)*r-a)*length(st)*8.0*volume;
        d = cos(floor(n+a/r)*r-a)*length(st)*8.0*volume;
        color = vec3(1.0 - smoothstep(0.,0.5,d));
    
        gl_FragColor = vec4(color, 1.0);
    }
</script>
<script type="fsh" id="fragmentShaderMichelle">
#ifdef GL_ES
precision mediump float;
#endif
uniform float time;
uniform float freqdata[16];
uniform float volume;
uniform vec2 resolution;
// 2D Random
float random (in vec2 st) {
    return fract(sin(dot(st.xy,
                         vec2(12.9898,78.233)))
                 * 43758.5453123);
}
// 2D Noise based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);
    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));
    // Smooth Interpolation
    // Cubic Hermine Curve.  Same as SmoothStep()
    vec2 u = f*f*(3.0-2.0*f);
    // u = smoothstep(0.,1.,f);
    // Mix 4 coorners porcentages
    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}
void main() {
   vec2 st = gl_FragCoord.xy/resolution.xy;
   st -= 0.5;
   st *= 2.;
   st = fract(st);
    vec3 color = vec3(0.259, 0.182, 0.78);
    vec2 pos = vec2(0.)-st;
    float radius = length(pos)*0.07/volume;
    float n = noise(st);
    float a = atan(pos.y+n-.15, pos.x+n-.15)/volume*.5;
    float f = (cos(a*3.));
    f = abs(cos(a*3.));
    f = abs(cos(a*12.)*sin(a*3.))*(.8)*.1;
    color += color/(volume+0.1)*.1;
    color += vec3((volume+0.3)*.3-smoothstep(f, f+0.02, radius));
    float opacity = 1.0;
    gl_FragColor = vec4(color, opacity);
   
}
</script>
<script type="fsh" id="fragmentShaderEmmy">
    uniform float time;
    uniform float freqData[16];
    uniform float volume;
    uniform vec2 resolution;
    // 2D Random
float random (in vec2 st) {
    return fract(sin(dot(st.xy,
                         vec2(12.9898,78.233)))
                 * 43758.5453123);
}
// 2D Noise based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);
    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));
    // Smooth Interpolation
    // Cubic Hermine Curve.  Same as SmoothStep()
    vec2 u = f*f*(3.0-2.0*f);
    // u = smoothstep(0.,1.,f);
    // Mix 4 coorners porcentages
    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}
    void main(){
        float volume_of_bass = freqData[15]/255.;
        float volume_of_high_pitch = freqData[0]/255.;
        float volume_of_medium_pitch = freqData[7]/255.;
            vec2 st = gl_FragCoord.xy/resolution.xy;
            st = st - 0.5;
            // st = fract(st);
            vec3 color = vec3(0.0);
            vec2 pos = vec2(0.5) - st;
            float n = noise(st);
            float r = length(pos) * (2.0 - volume_of_high_pitch/10.) ;
            float a = atan(pos.y + (volume_of_medium_pitch-volume_of_bass), pos.x + volume_of_bass);
            float f = smoothstep(-.5 + n, 1. , cos(a*10.) + n)*(0.2 + (volume_of_high_pitch - volume_of_bass)/5.)+ 0.5 + (volume_of_high_pitch) - volume_of_bass;
            color = vec3(1.-smoothstep(f, f+0.02, r) - 0.2 , volume_of_bass*2. - 0.2 + n, volume_of_medium_pitch*2. - 0.5 + n);
            gl_FragColor = vec4(color, 1.0);
    }
</script>
<script type="fsh" id="fragmentShaderAlex">
    
    uniform float time;
    uniform float freqData[16];
    uniform float volume;
    uniform vec2 resolution;
    // 2D Random
    float random (in vec2 st) {
        return fract(sin(dot(st.xy,
                             vec2(12.9898,78.233)))
                     * 43758.5453123);
    }
    // 2D Noise based on Morgan McGuire @morgan3d
    // https://www.shadertoy.com/view/4dS3Wd
    float noise (in vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);
        // Four corners in 2D of a tile
        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));
        // Smooth Interpolation
        // Cubic Hermine Curve.  Same as SmoothStep()
        vec2 u = f*f*(3.0-2.0*f);
        // u = smoothstep(0.,1.,f);
        // Mix 4 coorners porcentages
        return mix(a, b, u.x) +
                (c - a)* u.y * (1.0 - u.x) +
                (d - b) * u.x * u.y;
    }
    void main() {
        vec2 st = gl_FragCoord.xy/resolution.xy;
        st = st-1.;
        float n = noise(st);
        float r = length(st) * 2.0;
        float a = atan(st.y, st.x) + (2.0 * sin(time+n));
        float f = (2.0 * volume) * (cos(24. * a) + sin(16. * a));
        vec3 color = vec3(1., sin(time * 2.), cos(time)) * vec3(noise(st) + 1., noise(st) + 1., noise(st) + 1.) * vec3(1.0 * volume, 0.5 * volume, 2.0 * volume) * vec3(1. - smoothstep(f, f + 0.02, r));
        
        gl_FragColor = vec4(color, 1.);
    }
</script>
<script type="fsh" id="fragmentShaderBryan">
    uniform float time;
    uniform float volume;
    uniform vec2 resolution;
    uniform mat4 freqData[16];
    vec2 random2( vec2 p ) {
        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
    }
    void main(){
        vec2 st = gl_FragCoord.xy/resolution.xy;
        st = st-1.;
        st *= 2.;
        // st *= (2. - 1.5*volume);
        vec2 i_st = floor(st);
        vec2 f_st = fract(st);
        vec3 color = vec3(1.);
        float m_dist = .1 + .9 * volume;  // minimun distance
        for (int y= -1; y <= 1; y++) {
            for (int x= -1; x <= 1; x++) {
                // Neighbor place in the grid
                vec2 neighbor = vec2(float(x),float(y));
                // Random position from current + neighbor place in the grid
                vec2 point = random2(i_st + neighbor);
                float vol = volume * 2. - 1.;
                // Animate the point
                point = vec2(.5 * vol * .25 * random2(st).x, .5 * vol * .25 * random2(st).y) + vec2(.5*sin(time + 6.2831*point));
                // Vector between the pixel and the point
                vec2 diff = neighbor + point + f_st;
                // Distance to the point
                float dist = volume * length(diff);
                // Keep the closer distance
                m_dist = min(m_dist, dist);
            }
        }
        
        // color = vec3(1.) - distance*vec3(3.,2.,1.);
        
        //gl_FragColor = vec4(f * color, 1.);
        // gl_FragColor = vec4(color * inFunction, 1.);
        color = volume * vec3(f_st.x, i_st.y, freqData[1] / 255.);
        // Draw the min distance (distance field)
        color -= m_dist;
        // Draw cell center
        color += 1.-step(.02, m_dist);
        // Show isolines
        // color -= step(.7,abs(sin(27.0*m_dist)))*.5;
        gl_FragColor = vec4(color, 1.0);
    }
</script>
<script type="fsh" id="fragmentShaderPause">
    void main() {
        gl_FragColor = vec4(0.,0.,0., 1.);
    }
</script>
<script src="bower_components/three.js/build/three.js"></script>
<script>
	var camera, scene, renderer, mesh;
    var playing, listener, sound, audioLoader, analyser;


	function resize(){

	}

	function init() {

        // width = 500, height = 500;

		container = document.getElementById( 'container' );
        camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
        scene = new THREE.Scene();

        var geometry = new THREE.PlaneBufferGeometry( 2, 2 );

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        container.appendChild( renderer.domElement );

        // var size = (window.innerWidth > window.innerHeight) ? window.innerWidth : window.innerHeight;
        var size = 500;
        renderer.setSize( size, size ) ;

        var resolution = new THREE.Vector2();
        resolution.x = size;
        resolution.y = size;

        uniforms = {
            time: { value: 0 },
            freqData: { value: null },
            volume: { value: null },
            resolution: {value: resolution}
        };

        var material = new THREE.ShaderMaterial( {
            uniforms: uniforms,
            transparent: true,
            vertexShader: document.getElementById( 'vertexShader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentShaderAlex' ).textContent
        } );

        mesh = new THREE.Mesh( geometry, material );
        scene.add( mesh );

        window.addEventListener( 'resize', resize, false );
	}
    var previousVolume = 0;
    var whoseTurn = 0;
	function update(){
        var materialKristie = new THREE.ShaderMaterial( {
            uniforms: uniforms,
            transparent: true,
            vertexShader: document.getElementById( 'vertexShader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentShaderKristie' ).textContent
        } );
        var materialYoshino = new THREE.ShaderMaterial( {
            uniforms: uniforms,
            transparent: true,
            vertexShader: document.getElementById( 'vertexShader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentShaderYoshino' ).textContent
        } );
        var materialMichelle = new THREE.ShaderMaterial( {
            uniforms: uniforms,
            transparent: true,
            vertexShader: document.getElementById( 'vertexShader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentShaderMichelle' ).textContent
        } );
        var materialEmmy = new THREE.ShaderMaterial( {
            uniforms: uniforms,
            transparent: true,
            vertexShader: document.getElementById( 'vertexShader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentShaderEmmy' ).textContent
        } );
        var materialAlex = new THREE.ShaderMaterial( {
            uniforms: uniforms,
            transparent: true,
            vertexShader: document.getElementById( 'vertexShader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentShaderAlex' ).textContent
        } );
        var materialBryan = new THREE.ShaderMaterial( {
            uniforms: uniforms,
            transparent: true,
            vertexShader: document.getElementById( 'vertexShader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentShaderBryan' ).textContent
        } );
        var materials = [materialYoshino, materialEmmy, materialMichelle, materialKristie, materialAlex, materialBryan];
    
        if (playing)
            mesh.material.uniforms['time'].value += .005;

        var freqDataInt = analyser.getFrequencyData();
        var freqData = Array.from(freqDataInt);
        mesh.material.uniforms['freqData'].value = freqData;

        var volume = 0;
        for(var i=0; i<freqData.length; i++){
            volume += freqData[i];
        }

        volume = volume/freqData.length;

        // if volume is greater than previous volume by threshold amount, switch materials
        if (volume - previousVolume > (previousVolume*0.25)) {
            whoseTurn = (whoseTurn + 1) % materials.length;
            mesh.material = materials[whoseTurn];
        }
        previousVolume = volume;

        mesh.material.uniforms['volume'].value = volume/256;
	}

	function animate(){

		update();
		renderer.render(scene, camera);
		window.requestAnimationFrame(animate);

	}

    function toggleplay(){

        if(playing){
            sound.pause();
            playing = false;
            document.getElementById('play').innerHTML = 'play';
        }
        else{
            sound.play();
            playing = true;
            document.getElementById('play').innerHTML = 'pause';

        }

    }


    listener = new THREE.AudioListener();

    // create an Audio source
    sound = new THREE.PositionalAudio( listener );

    // load a sound and set it as the Audio object's buffer
    audioLoader = new THREE.AudioLoader();
    audioLoader.load( 'assets/rockstar.mp3', function( buffer ) {
        sound.setBuffer( buffer );
        sound.setVolume(0.7);
        sound.setRefDistance( 20 );
    });

    var whichSong = 0;
    var songs = ['assets/rockstar.mp3', 'assets/midnightcity.mp3', 'assets/mgmtkids.mp3', 'assets/tobucandyland.mp3', 'assets/hydrate.mp3', 'assets/madeonbeings.mp3', 'assets/ajrcomehangout.mp3'];
    var noSongChange = true;
    function toggleSong() {
        sound.stop();
        whichSong = (whichSong + 1) % songs.length;
        audioLoader.load( songs[whichSong], function( buffer ) {
            sound.setBuffer( buffer );
            sound.setVolume(0.7);
            sound.setRefDistance( 20 );
            sound.play();
        });
        noSongChange = false;
        playing = true;
        document.getElementById('play').innerHTML = 'pause';
    }

    // create an AudioAnalyser, passing in the sound and desired fftSize
    analyser = new THREE.AudioAnalyser( sound, 32 );

    THREE.DefaultLoadingManager.onLoad = function(){
        document.getElementById('loading').style.display = 'none';

        if (noSongChange)
            init();

        animate();

        var b = document.getElementsByClassName('startButton')[0];
        b.addEventListener('mousedown', function(){
            toggleplay();
            document.getElementById('start').style.opacity = 0;
            setTimeout(function(){
                document.getElementById('start').style.display = 'none';
            }, 500);
        })
    }


</script>
</html>